//
// Copyright (C) 2022 Motoyuki Kasahara.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>
//

#ifndef GOBB_ANALYZER_ANALYZER_HPP
#define GOBB_ANALYZER_ANALYZER_HPP

#include <cstddef>
#include <cstdint>
#include <string>
#include <fmt/core.h>
#include "definitions.hpp"
#include "position.hpp"

///
/// @file   analyzer.hpp
/// @brief  Define the class `Analyzer` and its related types.
///
namespace gobb_analyzer {

///
/// The number of positions needed for analysis.
///
/// All position IDs equal to or greater than `AnalysisDataTableSize` (defined here), have a symmetric
/// position with a position ID smaller than `AnalysisDataTableSize`.  We do not need to analyze
/// those positions.
///
/// Please refer to `sizedpositionid_maps.cpp` in the build directory (generated by a Python script),
/// for details about the value of 776.
///
constexpr PositionId AnalysisDataTableSize =
    (776u * PieceQuadCombinationNums * PieceQuadCombinationNums) +
    (PieceQuadCombinationNums * PieceQuadCombinationNums) +
    PieceQuadCombinationNums;

///
/// The repetition counter of analysis process.
///
/// We call the counter `generation`.
///
using Generation = std::uint16_t;

/// The maximum value of the repetition counter.
constexpr Generation MaxGeneration = 0x0ffeu;

/// The invalid value of the repetition counter.
constexpr Generation InvalidGeneration = 0x0fffu;

///
/// Analysis data about a position.
///
/// It consists of an update flag (1 bit), the number of remaining turns (12 bits) and a status code (3 bits).
///
using AnalysisData = std::uint16_t;

///
/// The number of remaining turns in the game, assuming that both players play perfectly.
///
using Turn = std::uint16_t;

/// The maximum number of remaining turns in a game.
static constexpr Turn MaxTurn = 0x0ffeu;

////////////////////////////////////////////////////////////////////////////

///
/// Analysis status code about a position.
///
enum class AnalysisStatus: std::uint8_t {
    Unfixed       = 0u,  ///< Not fixed.
    Lost          = 1u,  ///< The active player loses.
    LostStalemate = 2u,  ///< The active player loses with stalemate.
    Won           = 3u,  ///< The active player wins.
    WonStalemate  = 4u,  ///< The active player wins with stalemate.
    Transformed   = 5u,  ///< The position is ignored, since it can be transformed to another symmetric position
                         ///< with a smaller position ID.
    Contradictory = 6u,  ///< The position is never appeared during a game.
    Invalid       = 7u,  ///< Invalid.
};

/// The number of status codes about a position.
static constexpr int AnalysisStatusNums = 8;

///
/// Return the update flag recorded in the analysis data.
///
/// @param   data  analysis data about a position.
/// @return  the update flag.
///
inline bool updateFlag_of_analysisData(AnalysisData data) {
    return (data & 0x8000u) != 0;
}

///
/// Return the number of remaining turns recorded in the analysis data.
///
/// @param   data  analysis data about a position.
/// @return  the number of remaining turns.
///
inline Turn turn_of_analysisData(AnalysisData data) {
    return (data & 0x7ff8u) >> 3;
}

///
/// Return the status code recorded in the analysis data.
///
/// @param   data  analysis data about a position.
/// @return  the status code.
///
inline AnalysisStatus status_of_analysisData(AnalysisData data) {
    return static_cast<AnalysisStatus>(data & 0x0007u);
}

///
/// Construct analysis data from an update flag, the number of remaining turns and the status code.
///
/// @param   updateFlag  an update flag.
/// @param   turn        the number of remaining turns.
/// @param   status      a status code.
/// @return  an analysis data.
///
inline AnalysisData to_analysisData(bool updateFlag, Turn turn, AnalysisStatus status) {
    return (static_cast<AnalysisData>(updateFlag) << 15) |
        ((turn & 0x0fffu) << 3) |
        (static_cast<AnalysisData>(status) & 0x0007u);
}

///
/// Set the update flag in the analysis data.
///
/// @param   data        analysis data of a position.
/// @param   updateFlag  a value to be set.
/// @return  the resulting analysis data.
///
inline AnalysisData set_updateFlag_of_analysisData(AnalysisData data, bool updateFlag) {
    return (data & 0x7fffu) | (static_cast<AnalysisData>(updateFlag) << 15);
}

///
/// Set the number of remaining turns in the analysis data.
///
/// @param   data  analysis data of a position.
/// @param   turn  a value to be set.
/// @return  the resulting analysis data.
///
inline AnalysisData set_turn_of_analysisData(AnalysisData data, Turn turn) {
    return (data & 0x8007u) | ((turn & 0x0fffu) << 3);
}

///
/// Set the status code in the analysis data.
///
/// @param   data    analysis data of a position.
/// @param   status  a value to be set.
/// @return  the resulting analysis data.
///
inline AnalysisData set_status_of_analysisData(AnalysisData data, AnalysisStatus status) {
    return (data & 0xfff8u) | (static_cast<AnalysisData>(status) & 0x0007u);
}

///
/// Check if the status code in the analysis data is valid.
///
/// @param   status  a status code.
/// @return  the varidation result.
///
/// It returns true if status is `Unfixed`, `Lost`, `LostStalemate`, `Won`, `WonStalemate` or `Transformed`
/// or `Contradictory`.
///
inline bool is_valid_analysisStatus(AnalysisStatus status) {
    return (status <= AnalysisStatus::Contradictory);
}

///
/// Inverse the status code in the analysis data.
///
/// @param   status  a status code.
/// @return  the resulting analysis code.
///
/// It inverts the status code.  It returns `Win` for `Lost`, WinStalemete` for `LostStalemate',
/// `Lost` for `Win` and `LostStalemate` for `WinStalemate`.
/// It returns `status` for other status codes.
///
inline AnalysisStatus invert_analysisStatus(AnalysisStatus status) {
    switch (status) {
    case AnalysisStatus::Lost:
        return AnalysisStatus::Won;
    case AnalysisStatus::LostStalemate:
        return AnalysisStatus::WonStalemate;
    case AnalysisStatus::Won:
        return AnalysisStatus::Lost;
    case AnalysisStatus::WonStalemate:
        return AnalysisStatus::LostStalemate;
    default:
        return status;
    }
}

///
/// Return a name of the analysis status code.
///
/// @param   status  a status code.
/// @return  a name of the status code.
///
/// It returns "Invalid" if `status` is not valid.
///
const std::string& analysisStatus_to_string(AnalysisStatus status);

/// The maximum length of a string returned from `TransformerId_to_string()`.
constexpr std::size_t AnalysisStatusStringMaxLen = 13u;

/// The maximum length of a string returned from `TransformerId_to_string()` for a valid ID.
constexpr std::size_t ValidAnalysisStatusStringMaxLen = 13u;

////////////////////////////////////////////////////////////////////////////

///
/// Analysis statistics.
///
struct AnalysisStatistics {
    PositionId lostNums;           ///< The number of positions marked with `AnalysisStatus::Lost`.
    PositionId lostStalemateNums;  ///< The number of positions marked with `AnalysisStatus::LostStalemate`.
    PositionId wonNums;            ///< The number of positions marked with `AnalysisStatus::Won`.
    PositionId transformedNums;    ///< The number of positions marked with `AnalysisStatus::Transformed`.
    PositionId contradictoryNums;  ///< The number of positions marked with `AnalysisStatus::Contradictory`.
    PositionId unfixedNums;        ///< The number of positions marked with `AnalysisStatus::Unfixed`.

    ///
    /// Default constructor.
    ///
    /// All counters are set to 0.
    ///
    AnalysisStatistics() noexcept;

    ///
    /// Copy constructor.
    ///
    /// @param   other  an instance to copy from.
    ///
    /// It constructs an instance with a copy of the contents of `other`.
    ///
    AnalysisStatistics(const AnalysisStatistics& other) noexcept = default;

    ///
    /// Move constructor.
    ///
    /// @param   other  an instance to move from.
    ///
    /// It constructs an instance with the contents of `other` using move semantics.
    ///
    AnalysisStatistics(AnalysisStatistics&& other) noexcept = default;

    ///
    /// Copy assignment operator.
    ///
    /// @param   other  an instance to copy from.
    /// @return  a reference of `*this`.
    ///
    /// It replaces the contents with a copy of `other`.
    ///
    AnalysisStatistics& operator=(const AnalysisStatistics& other) noexcept = default;

    ///
    /// Move assignment operator.
    ///
    /// @param   other  an instance to move from.
    /// @return  a reference of `*this`.
    ///
    /// It replaces the contents with those of `other` using move semantics.
    ///
    AnalysisStatistics& operator=(AnalysisStatistics&& other) noexcept = default;

    ///
    /// Destructor.
    ///
    ~AnalysisStatistics() = default;

    ///
    /// Reset all counters.
    ///
    void clear() noexcept;

    ///
    /// Adds values of counters in `other` to `this`.
    ///
    /// @param   other  an instance.
    ///
    void add(const AnalysisStatistics& other) noexcept;
};

////////////////////////////////////////////////////////////////////////////

///
/// I/O handler for loading and storing analysis data.
///
/// This is an abstract class.
///
class AnalysisDataIOHandler {
public:
    ///
    /// Destructor.
    ///
    virtual ~AnalysisDataIOHandler();

    ///
    /// Store analysis data and its statistics.
    ///
    /// @param   generation  a generation.
    /// @param   stats       statistics data.
    /// @param   table       a table of analysis data.
    /// @param   tableSize   the number of elements in `table`.
    /// @return  true upon success.
    ///
    virtual bool store(Generation generation, const AnalysisStatistics& stats,
        const AnalysisData* table, std::size_t tableSize) = 0;

    ///
    /// Load analysis data and its statistics.
    ///
    /// @param   generation  a generation.
    /// @param   stats       statistics data.
    /// @param   table       a table of analysis data.
    /// @param   tableSize   the number of elements in `table`.
    /// @return  true upon success.
    ///
    /// Upon success, the loaded analysis data and its statistics data are written in `table` and `stats`.
    ///
    virtual bool load(Generation generation, AnalysisStatistics& stats,
        AnalysisData* table, std::size_t tableSize) const = 0;

    ///
    /// Finds the latest generation of stored analysis data.
    ///
    /// @return  a generation number.
    ///
    /// It returns -1 if no analysis data are found.
    ///
    virtual Generation find_latest() const = 0;

    ///
    /// Load analysis data of the latest generation.
    ///
    /// @param   stats      statistics data.
    /// @param   table       a table of analysis data.
    /// @param   tableSize  the number of elements in `table`.
    /// @return  the generation number of the loaded data.
    ///
    /// The function finds analysis data with the largest generation number and loads them.
    /// Upon success, the loaded analysis data and its statistics are written to `table` and `stats`
    /// and it returns the generation number.
    /// Otherwise, it returns -1.
    ///
    virtual Generation load_latest(AnalysisStatistics& stats, AnalysisData* table, std::size_t tableSize) const = 0;

    ///
    /// Removes resources not used any longer for loading and storing analysis data.
    ///
    virtual void clean() = 0;
};

////////////////////////////////////////////////////////////////////////////

///
/// A flag to select how often to store the analysis data.
///
enum class AnalysisDataIOMode {
    StoreNoGeneration     = 0,  ///< Never (for benchmark).
    StoreEveryGenerations = 1,  ///< Every generations.
    StoreFinalGeneration  = 2   ///< Final generation only.
};

////////////////////////////////////////////////////////////////////////////

///
/// Log messages of the analysis processing.
///
/// This is an abstract class.
///
class AnalysisLogger {
public:
    ///
    /// Destructor.
    ///
    virtual ~AnalysisLogger();

    ///
    /// Log the informational message without any text.
    ///
    /// Whether or not to record the empty message actually depends on the concrete logger instance.
    ///
    virtual void info() = 0;

    ///
    /// Log the informational message.
    ///
    /// @param   message  a message.
    ///
    virtual void info(const std::string& message) = 0;

    ///
    /// Log the informational message.
    ///
    /// @param   fmt   a format.
    /// @param   args  arguments corresponding with `fmt`.
    ///
    template<typename ...T>
    void info(fmt::format_string<T...> fmt, T&&... args) {
        info(fmt::format(fmt, args...));
    }

    ///
    /// Log the notification message without any text.
    ///
    /// Whether or not to record the empty message actually depends on the concrete logger instance.
    ///
    virtual void notice() = 0;

    ///
    /// Log the notification message.
    ///
    /// @param   message  a message.
    ///
    virtual void notice(const std::string& message) = 0;

    ///
    /// Log the notification message.
    ///
    /// @param   fmt   a format.
    /// @param   args  arguments corresponding with `fmt`.
    ///
    template<typename ...T>
    void notice(fmt::format_string<T...> fmt, T&&... args) {
        notice(fmt::format(fmt, args...));
    }

    ///
    /// Log a warning message without any text.
    ///
    /// Whether or not to record the empty message actually depends on the concrete logger instance.
    ///
    virtual void warn() = 0;

    ///
    /// Log the warning message.
    ///
    /// @param   message  a message.
    ///
    virtual void warn(const std::string& message) = 0;

    ///
    /// Log the warning message.
    ///
    /// @param   fmt   a format.
    /// @param   args  arguments corresponding with `fmt`.
    ///
    template<typename ...T>
    void warn(fmt::format_string<T...> fmt, T&&... args) {
        warn(fmt::format(fmt, args...));
    }

    ///
    /// Log the error message without any text.
    ///
    /// Whether or not to record the empty message actually depends on the concrete logger instance.
    ///
    virtual void error() = 0;

    ///
    /// Log the error message.
    ///
    /// @param   message  a message.
    ///
    virtual void error(const std::string& message) = 0;

    ///
    /// Log the error message.
    ///
    /// @param   fmt   a format.
    /// @param   args  arguments corresponding with `fmt`.
    ///
    template<typename ...T>
    void error(fmt::format_string<T...> fmt, T&&... args) {
        error(fmt::format(fmt, args...));
    }
};

////////////////////////////////////////////////////////////////////////////

///
/// Perform retrograde analsys of Gobblet Gobblers.
///
/// In the retrograde analsys, we perform the following procedures for all positions.
///
/// * If a position P is marked with Lost or LostStalemate, we mark all the previous positions of P with Win.
/// * If all the subsequent positions of the position P are marked with either Won or WonStalemate,
///   we mark the position P with Lost.
///
/// We finish analyzing when no update occurs on any position.
///
class Analyzer {
public:
    ///
    /// Constructor.
    ///
    /// @param   logger  a logging instance to output messages.
    ///
    Analyzer(AnalysisLogger& logger);

    Analyzer(const Analyzer& other) = delete;
    Analyzer(Analyzer&& other) = delete;
    Analyzer& operator=(const Analyzer& other) = delete;
    Analyzer& operator=(Analyzer&& other) = delete;

    ///
    /// Destructor.
    ///
    virtual ~Analyzer();

    ///
    /// Start retrograde analysis from the beginning.
    ///
    /// @param   handler  an I/O handler to store the analysis data.
    /// @param   mode     how often to store the analysis data.
    /// @return  true upon success.
    ///
    /// It does not load an existing analysis data.
    ///
    bool start(AnalysisDataIOHandler& handler, AnalysisDataIOMode mode);

    ///
    /// Resume retrograde analysis.
    ///
    /// @param   handler  an I/O handler to store the analysis data.
    /// @param   mode     how often to store the analysis data.
    /// @return  true upon success.
    ///
    /// It loads the analysis data of the latest generation stored by the I/O handler, then resumes
    /// retrograde analysis.
    /// If no stored analysis data is found, it reports a warning and starts retrograde analysis from
    /// the beginning.
    ///
    bool resume(AnalysisDataIOHandler& handler, AnalysisDataIOMode mode);

    ///
    /// Resume retrograde analysis.
    ///
    /// @param   handler     an I/O handler to store the analysis data.
    /// @param   mode        how often to store the analysis data.
    /// @param   generation  a generation number of the stored analysis data.
    /// @return  true upon success.
    ///
    /// It loads the analysis data of the specified generation stored by the I/O handler, then resumes
    /// retrograde analysis.
    /// If the stored analysis data is not found or it fails to load the analysis data, it reports an error
    /// and returns false.
    ///
    bool resume(AnalysisDataIOHandler& handler, AnalysisDataIOMode mode, Generation generation);

private:
    ///
    /// Initialize a table of analysis data.
    ///
    /// @return  true if the table has been updated.
    ///
    /// It sets an initial data for each position.
    ///
    bool initialize() noexcept;

    ///
    /// Perform retrograde analysis.
    ///
    /// @param   handler  an I/O handler to store the analysis data.
    /// @param   mode     how often to store the analysis data.
    /// @return  true if the table has been updated.
    ///
    /// start() and resume() calls this member function internally to perform retrograde analysis.
    ///
    bool analyze(AnalysisDataIOHandler& handler, AnalysisDataIOMode mode);

    ///
    /// Perform retrograde analysis of the current generation.
    ///
    /// @param   stats  statistics of the current generation.
    /// @return  true if the table has been updated.
    ///
    bool analyze_generation(AnalysisStatistics& stats) noexcept;

    ///
    /// Update analysis status of previous positions of the position marked with Lost or LostStalemate.
    ///
    /// @param   stats  statistics data of the current generation.
    /// @param   pos    a position marked with Lost or LostStalemate.
    /// @return  true if the analysis data table has been updated.
    ///
    /// If a position P is marked with Lost or LostStalemate, we mark all the previous positions of P
    /// with Win.
    ///
    bool analyze_move_backs_from_active_player_lost(AnalysisStatistics& stats, const Position& pos) noexcept;

    ///
    /// Update analysis status of positions just before the position marked with Won or WonStalemate.
    ///
    /// @param   stats  statistics data of the current generation.
    /// @param   pos    a position marked with Won or WonStalemate.
    /// @return  true if the analysis data table has been updated.
    ///
    /// If a position P is marked with Won or WonStalemate, we set the update flags of all the previous
    /// positions of P.
    ///
    bool analyze_move_backs_from_active_player_won(AnalysisStatistics& stats, const Position& pos) noexcept;

    ///
    /// Try to update analysis status of a position marked with Unfixed.
    ///
    /// @param   stats  statistics data of the current generation.
    /// @param   pos    a position marked with Unfixed.
    /// @return  true if the analysis data table has been updated.
    ///
    /// If all the subsequent positions of the position P are marked with either Won or WonStalemate,
    /// we mark the position P as Lost.
    ///
    bool analyze_unfixed(AnalysisStatistics& stats, const Position& pos) noexcept;

    ///
    /// Count possible movements at the position.
    ///
    /// @param   pos  a position.
    /// @return  the number of possible movements.
    ///
    /// It counts movements that `pos.move()` returns `MoveResultStatus::Success`.
    ///
    int move_nums(const Position& pos) const noexcept;

    ///
    /// At the position, count pieces on the board owned by the specified player.
    ///
    /// @param   pos  a position.
    /// @param   player  a player.
    /// @return  the number of pieces owned by the player.
    ///
    int on_board_piece_nums(const Position& pos, PlayerId player) const noexcept;

    ///
    /// Output statistics report.
    ///
    /// @param   generation  a generation number.
    /// @param   stats  statistics data of the current generation.
    ///
    void log_statistics(Generation generation, AnalysisStatistics& stats);

    /// The current generation.
    Generation generation_;

    /// The generation of the last stored analysis data.
    Generation storedGeneration_;

    /// Analysis data of all positions.
    AnalysisData* analysisDataTable_;

    /// Statistics of the analysis.
    AnalysisStatistics statistics_;

    /// Logger.
    AnalysisLogger& logger_;
};

} // namespace gobb_analyzer

#endif // GOBB_ANALYZER_ANALYZER_HPP
