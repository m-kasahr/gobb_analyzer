//
// Copyright (C) 2022 Motoyuki Kasahara.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>
//

#ifndef GOBB_ANALYZER_INSPECTOR_HPP
#define GOBB_ANALYZER_INSPECTOR_HPP

#include <cstddef>
#include <vector>
#include "analyzer.hpp"

///
/// @file   inspector.hpp
/// @brief  Define the class `Inspector` and its related types.
///
namespace gobb_analyzer {

///
/// Inspection result of a position.
///
struct PositionInspectionResult {
    PositionId positionId;          ///< a position ID.
    Turn turn;                      ///< the number of remaining turns.
    AnalysisStatus analysisStatus;  ///< the status code of the position.
};

///
/// Inspection result of a possible move.
///
struct MoveInspectionResult {
    PieceId piece;                  ///< a piece to be moved.
    LocationId source;              ///< the source location of the piece.
    LocationId destination;         ///< the destination of the piece.
    PositionId positionId;          ///< a position ID after moving the piece.
    Turn turn;                      ///< the number of remaining turns.
    AnalysisStatus analysisStatus;  ///< the status code of a position after moving the piece.
    bool isBestMove;                ///< true if this is the best move among the candidates.
};

///
/// Inspect analysis data generated by `Analyzer`.
///
class Inspector {
public:
    ///
    /// Default constructor.
    ///
    Inspector();

    Inspector(const Inspector& other) = delete;
    Inspector(Inspector&& other) = delete;
    Inspector& operator=(const Inspector& other) = delete;
    Inspector& operator=(Inspector&& other) = delete;

    ///
    /// Destructor.
    ///
    virtual ~Inspector();

    ///
    /// Load the analysis data of the specified generation.
    ///
    /// @param   handler     an I/O handler to store the analysis data.
    /// @param   generation  a generation number.
    /// @return  true upon success.
    ///
    /// It loads the analysis data of the specified generation stored by the I/O handler.
    ///
    bool load(AnalysisDataIOHandler& handler, Generation generation);

    ///
    /// Load the analysis data of the latest generation.
    ///
    /// @param   handler  an I/O handler to store the analysis data.
    /// @return  the generation of the loaded data.
    ///
    /// It loads the analysis data of the latest generation stored by the I/O handler.
    /// It returns -1 if no stored analysis data is found or it fails to load the data.
    ///
    Generation load_latest(AnalysisDataIOHandler& handler);

    ///
    /// Return analysis data of the specified position.
    ///
    /// @param   id  a position ID.
    /// @return  analysis data.
    ///
    PositionInspectionResult inspect_position(PositionId id) const noexcept;

    ///
    /// Return a list of possible moves of the specified position.
    ///
    /// @param   id  a position ID.
    /// @return  a list of possible moves.
    ///
    std::vector<MoveInspectionResult> inspect_moves(PositionId id) const noexcept;

    ///
    /// Return a list of possible retrograde moves of the specified position.
    ///
    /// @param   id  a position ID.
    /// @return  a list of possible retrograde moves.
    ///
    std::vector<MoveInspectionResult> inspect_move_backs(PositionId id) const noexcept;

private:
    ///
    /// Mark the best moves among the candidates.
    ///
    /// @param   moveInspectionResults  a vector of `MoveInspectionResult`.
    ///
    void mark_best_move(std::vector<MoveInspectionResult>& moveInspectionResults) const noexcept;

    /// Analysis data of all positions.
    AnalysisData* analysisDataTable_;

    /// Statistics of the analysis.
    AnalysisStatistics statistics_;
};

} // namespace gobb_analyzer

#endif // GOBB_ANALYZER_INSPECTOR_HPP
